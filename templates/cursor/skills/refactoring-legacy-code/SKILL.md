---
name: refactoring-legacy-code
description: レガシーコードの改善とリファクタリングの実践手法。テストコードがないコードを安全に改善するための手順とパターン。t-wadaさんの「実録レガシーコード改善」をベースにした実践的なアプローチ。
---

# レガシーコード改善・リファクタリングスキル

## When to Use

- テストコードがない既存コードを改善する際
- レガシーコードに機能追加が必要な際
- コードの可読性・保守性を向上させたい際
- リファクタリングを安全に進めたい際
- 依存性の注入やシームを活用したい際

## Instructions

### 概要

このスキルは、t-wadaさんの「実録レガシーコード改善 / Working with Legacy Code: the True Record」をベースにした、レガシーコードを安全に改善するための実践的なアプローチです。

**重要な原則**: テストコードがないコードを改善するには、まずテストコードを書く必要があります。しかし、テストコードを書くためには、コードを変更する必要がある場合があります。この循環を解決するための手法を提供します。

### 基盤整備の優先順位

レガシーコード改善の基盤整備は、以下の順序で行います：

1. **Version Control**（バージョン管理）
2. **Testing**（テスト）
3. **Automation**（自動化）

#### 1. Version Control（バージョン管理）

- 現在のコードと設定ファイルをすべてGitに登録する
- 変更履歴を追跡できるようにする
- 必要に応じてコミットメッセージに変更理由を含める

#### 2. Testing（テスト）

- **自動テストがないと安全なコード変更と今後の開発継続が困難**
- 手動テストは時間がかかり、不安定で、リグレッションが発生しやすい
- 最初は「undefinedでなければ良い」程度の雑なテストでも良い
- リクエスト/レスポンスレベルを狙うと、実装から距離を取りつつ安定したテストを書ける

#### 3. Automation（自動化）

- 自動化は開発効率を大幅に向上させる
- チーム開発の効率化：一人が自動化すれば全員が受益者になる
- 例：CI/CDパイプラインを一度構築すれば、単純な作業の時間を安定して削減できる
- 簡単なスクリプトから始めるのが良い

### テスト駆動開発（TDD）のサイクル

レガクタリング時は、以下のサイクルを繰り返します：

1. **赤**: 次の目標を考えてテストステップを決める
2. **緑**: テストから一つアサーションを追加してその目標を表すテストを一つ書く
3. **赤**: そのテストを実行して失敗させる
4. **緑**: 目標を満たすコードを書く
5. **リファクタリング**: テストが通るままでリファクタリングする
6. **リファクタリング**: 1～5を繰り返す

### 依存性の注入とシーム（Seam）

#### シーム（Seam）とは

シームとは、その場所を変更せずに、プログラムの動作を変更できる場所のことです。

> 「シーム（Seam）とは、その場所を変更せずに、プログラムの動作を変更できる場所である。プログラムの動作を変更するために、その場所を変更する必要がない」
> 
> — 『レガシーコード改善ガイド』p.40

#### 依存性の注入（Dependency Injection）

ランダム性などの非決定性を扱う関数を外部から注入できるようにすることで、テストの決定性を担保できます。

**例: ランダム性の分離**

```javascript
// 変更前: ランダム性がコード内に埋め込まれている
var random = Math.floor(Math.random() * questions.length);

// 変更後: ランダム性を外部から注入できるようにする
var createHandler = function (getNextItemIndex) {
  return function (event, context, callback) {
    // getNextItemIndex関数を使用
  };
};

// テストでは固定値を返す関数を渡す
const getNextItemIndex = () => 4;
const handler = createHandler(getNextItemIndex);
```

### Humble Object Pattern

テストしやすさを下げている要素を外に追い出し、テスト可能範囲を広げる基本パターンです。

**原則**: 
- テストしにくい要素（フレームワーク固有の処理など）を外に追い出す
- ビジネスロジックをテスト可能な範囲に移動する

**例: Alexa Skillのハンドラーからロジックを分離**

```javascript
// 変更前: ロジックがハンドラー内に混在
QuizIntent: function () {
  this.attributes['advance'] = 1;
  this.attributes['score'] = 0;
  var random = Math.floor(Math.random() * questions.length);
  // ... ロジックが続く
}

// 変更後: ロジックをモデルクラスに分離
QuizIntent: function () {
  const session = new Session();
  session.start(questions[getNextItemIndex()]);
  this.attributes['dump'] = session.dump();
  this.emit(session.command(), session.message(), session.reprompt());
}
```

### Extract Method / Sprout Method

#### Extract Method（メソッドの抽出）

既存のコードにテストを書いて保護しながら、新しくコードを抽出して分離する手法。

**手順**:
1. 既存のコードにテストを書いて保護する
2. 新しくコードを抽出して分離する
3. テスト可能な範囲を広げる

#### Sprout Method（新芽メソッド）

既存のコードにテストを書くことが困難な場合、新しくコードを書く際にテストを書く手法。

**手順**:
1. 既存のコードにテストを書くことが困難な場合
2. 新しく書くコードだけテストを書く
3. 変更を小さく保つ

### モデルの抽出

#### 段階的なモデル抽出

1. **Plain Oldなモデルクラスを作成**
   - AlexaやLambdaに依存しない、テスト可能なクラスを作成
   - ビジネスロジックをモデルクラスに移動

2. **Lambdaからハンドラーを切り出す**
   - Lambdaレベルのテストのグリーンを保つため、リクエストをまたがるデータの持ち方は変えない
   - ロジックを切り出しただけの段階

3. **詳細な依存を減らしていく**
   - モデルの持っている情報をテストからも見えるようにして、Alexa固有の機能（attributes）への依存を減らしていく
   - Lambdaレベルのテストは引き続き動作するが、決定性にデータを追加する形で徐々に移行

4. **状態遷移をモデル自身が管理できるようにする**
   - 状態遷移に関するモデル自身が判断できるようにして、Lambda側の条件分岐を減らす

5. **結合点をさらに減らす**
   - クラスをexportせず、通常の関数のみをexportする
   - 情報隠蔽が進む

### 実装と情報の分離

#### データと情報の違い

- **データ**: 単なる各値の名前（何かの、名前とか住所とか電話番号とか）で、それ自体に目的がない
- **情報**: 意味のある（目的を持った）データを組み合わせて作られたもの

**原則**: データを構造化し、情報をそこから計算で取得できる方向に設計する

**例: 状態遷移のモデル化**

```javascript
// 変更前: データと情報が混在
dump: {
  advance: 7,
  score: 5,
  accumIncorrects: 0,
  item: { a: '盛岡', g: 'PrefecturalOfficeLocation', q: '岩手県の県庁所在地は？' }
}

// 変更後: データを構造化し、情報を計算で取得
dump: {
  startedAt: 1540553739000,
  finishedAt: null,
  blocks: [{
    startedAt: 1540553739000,
    finishedAt: 1540553825000,
    questions: [{
      item: { q: '山形県の県の花は？', a: 'べにばな' },
      startedAt: 1540553752000,
      finishedAt: 1540553778000,
      result: 'correct',
      attempts: [...]
    }]
  }]
}
```

### Clean Architectureの原則

#### 単一責任の原則（SRP）

- クラスやモジュールは、変更する理由が一つであるべき
- 変更の理由が異なるものは、別々に分離する

#### 依存関係逆転の原則（DIP）

- 安定した依存の高い方向に依存すること
- 安定した高レベルの方向に依存すること

#### 安定依存の原則

- 安定した方向に依存すること

#### 各レイヤーの役割

```
事実を扱う ← 情報を扱う ← 基盤を扱う ← 永続化を扱う
```

- **事実を扱う**: データから計算で取得できる情報を扱う
- **情報を扱う**: ビジネスロジック、76*などとしてのメッセージなどの処理
- **基盤を扱う**: フレームワーク固有の処理
- **永続化を扱う**: データベースやストレージへの保存

### リファクタリングの実践手順

#### 1. 現状把握

- コードを読んで理解する
- テストコードがない場合は、まずテストを書く
- リクエスト/レスポンスレベルでテストを書く

#### 2. テストの追加

- 「undefinedでなければ良い」程度の雑なテストから始める
- リクエスト/レスポンスレベルを狙う
- テストが通ることを確認する

#### 3. 依存性の分離

- ランダム性などの非決定性を外部から注入できるようにする
- シームを見つけて、依存性を外部化する

#### 4. モデルの抽出

- Plain Oldなモデルクラスを作成
- ビジネスロジックをモデルクラスに移動
- Lambdaレベルのテストのグリーンを保つ

#### 5. 段階的な改善

- 一度に大きく変更しない
- 小さなステップで進める
- 各ステップでテストが通ることを確認する

#### 6. 実装と情報の分離

- データを構造化する
- 情報を計算で取得できるようにする
- 状態遷移をモデル自身が管理できるようにする

#### 7. アーキテクチャの決定

- Clean Architectureの原則に従う
- 各レイヤーの役割を明確にする
- 依存関係を適切に管理する

### 注意事項

1. **テストがないコードを変更するには、まずテストを書く必要がある**
   - しかし、テストを書くためには、コードを変更する必要がある場合がある
   - この循環を解決するために、シームや依存性の注入を活用する

2. **一度に大きく変更しない**
   - 小さなステップで進める
   - 各ステップでテストが通ることを確認する

3. **テストのグリーンを保つ**
   - リファクタリング中も、既存のテストが通ることを確認する
   - テストが失敗した場合は、すぐに修正する

4. **実装から距離を取る**
   - リクエスト/レスポンスレベルでテストを書く
   - 実装の詳細に依存しないテストを書く

5. **決定性を担保する**
   - ランダム性などの非決定性を外部から注入できるようにする
   - テストでは固定値を返す関数を渡す

### 参考資料

- [実録レガシーコード改善 / Working with Legacy Code: the True Record](https://speakerdeck.com/twada/working-with-legacy-code-the-true-record)
- 『レガシーコード改善ガイド』（Michael Feathers著）
- 『Clean Architecture』（Robert C. Martin著）
- 『テスト駆動開発』（Kent Beck著）

### チェックリスト

リファクタリングを進める際のチェックリスト：

- [ ] バージョン管理（Git）が設定されているか
- [ ] テストコードが書かれているか（最低限でも）
- [ ] リクエスト/レスポンスレベルでテストが書かれているか
- [ ] ランダム性などの非決定性が外部から注入できるか
- [ ] シームを見つけて依存性を外部化できているか
- [ ] ビジネスロジックがモデルクラスに分離されているか
- [ ] Lambdaレベルのテストが通っているか
- [ ] 小さなステップで進めているか
- [ ] 各ステップでテストが通ることを確認しているか
- [ ] 実装と情報が分離されているか
- [ ] Clean Architectureの原則に従っているか
