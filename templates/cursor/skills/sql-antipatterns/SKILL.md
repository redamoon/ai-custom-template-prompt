---
name: SQLアンチパターン検出・修正スキル
description: SQLアンチパターン第2版（Bill Karwin著）に基づき、データベース設計やSQLクエリのアンチパターンを検出し、適切な解決策を提案する。
---

# SQLアンチパターン検出・修正スキル

このスキルは、データベース設計やSQLクエリのレビュー・作成時に使用します。「SQLアンチパターン第2版」（Bill Karwin著、和田卓人監訳、2024年）に基づき、よくある失敗パターンを検出し、適切な解決策を提案します。

## When to Use

- データベースのテーブル設計やスキーマ変更を行う際
- SQLクエリを作成・レビューする際
- マイグレーションファイルを作成する際
- ORMのモデル定義を作成・レビューする際
- データベース関連のコードレビューを行う際

## 参考資料

- [SQLアンチパターン第2版](https://www.oreilly.co.jp/books/9784814400850/)（Bill Karwin著、和田卓人監訳）
- [スライド資料: SQLアンチパターン第2版](https://speakerdeck.com/twada/intro-to-sql-antipatterns-2nd)（t_wada氏による発表資料）
- [YouTube: SQLアンチパターン第2版 解説動画](https://www.youtube.com/watch?v=mj62B0FlqKI)
- [Zenn: SQLアンチパターンを学ぶ](https://zenn.dev/kiitosu/articles/424317cfaa1ee1)（各章の具体例と補足情報が充実）

## Instructions

### 本書の構成

SQLアンチパターンは以下の4つのカテゴリに分類されます。

1. **第I部: データベース論理設計のアンチパターン** - テーブルや列、関連の設計に関する失敗
2. **第II部: データベース物理設計のアンチパターン** - インデックスやデータ型の定義に関する失敗
3. **第III部: クエリのアンチパターン** - SELECT、UPDATE、DELETEなどの記述に関する失敗
4. **第IV部: アプリケーション開発のアンチパターン** - SQLをアプリケーションで使用する際の失敗

### 各アンチパターンの構成

各アンチパターンは以下の要素で構成されています。

- **名前**: パターン名（短い言葉で本質を伝える）
- **目的**: 解決すべきタスク
- **アンチパターン**: よかれと思って裏目に出てしまう方法
- **アンチパターンの見つけ方**: プロジェクトでの察知方法
- **アンチパターンを用いてもよい場合**: 例外的に許容される状況
- **解決策**: 望ましい方法
- **ミニ・アンチパターン**: 章末の追加パターン

---

## 第I部: データベース論理設計のアンチパターン

### 1章 ジェイウォーク（信号無視）

**目的**: 複数の値を持つ属性を格納する。

**アンチパターン**: カンマ区切りフォーマットのリストを1つの列に格納する。

```sql
-- アンチパターン: カンマ区切りで多対多関連を格納
CREATE TABLE Products (
  product_id SERIAL PRIMARY KEY,
  product_name VARCHAR(1000),
  account_id VARCHAR(100) -- カンマ区切りのリスト
);

INSERT INTO Products (product_id, product_name, account_id)
VALUES (DEFAULT, 'Visual TurboBuilder', '12,34');
```

**問題点**
- 特定のアカウントに関連する製品の検索にインデックスが使えない
- JOINに正規表現を使う必要がある
- 集約クエリが複雑になる
- 更新にSQLを2つ発行する必要がある
- 外部キー制約による妥当性検証ができない
- リストの長さに制限がある

**解決策**: 交差テーブルを作成する。

```sql
-- 解決策: 交差テーブルを作成
CREATE TABLE Contacts (
  product_id BIGINT UNSIGNED NOT NULL,
  account_id BIGINT UNSIGNED NOT NULL,
  PRIMARY KEY (product_id, account_id),
  FOREIGN KEY (product_id) REFERENCES Products(product_id),
  FOREIGN KEY (account_id) REFERENCES Accounts(account_id)
);
```

**見つけ方**: 「このリストでサポートしなければならない最大のエントリ数は？」「SQLで単語境界を一致させる方法を知っている？」という会話が出たら要注意。

### 2章 ナイーブツリー（素朴な木）

**目的**: 階層構造を格納・クエリする。

**アンチパターン**: 常に親のみに依存する（隣接リストのみを使用）。

```sql
-- アンチパターン: 隣接リストのみ
CREATE TABLE Comments (
  comment_id SERIAL PRIMARY KEY,
  parent_id BIGINT UNSIGNED,
  comment TEXT NOT NULL,
  FOREIGN KEY (parent_id) REFERENCES Comments(comment_id)
);
```

**問題点**
- 深い階層のクエリが困難
- ノードの削除が複雑
- 再帰クエリのサポートが必要

**解決策**: 用途に応じて以下のいずれかを選択する。

- **経路列挙（Path Enumeration）**: パスを文字列として格納
- **入れ子集合（Nested Sets）**: 左値と右値で範囲を表現
- **閉包テーブル（Closure Table）**: 祖先と子孫のペアを格納
- **再帰CTE**: WITH RECURSIVEを使用した再帰クエリ

### 3章 IDリクワイアド（とりあえずID）

**目的**: 全テーブルの主キーの規約を確立する。

**アンチパターン**: すべてのテーブルにid列を追加する。

**問題点**
- 冗長なキーが作成される
- 重複行を許可してしまう
- キーの意味がわかりにくい

**解決策**: 状況に応じた主キーを設定する。自然キーが適切な場合はそれを使い、交差テーブルでは複合キーを使用する。

### 4章 キーレスエントリ（外部キー嫌い）

**目的**: データベース設計を簡素化する。

**アンチパターン**: 外部キー制約を省略する。

**問題点**
- 参照整合性が保証されない
- 孤児行が発生する
- アプリケーション側で整合性チェックが必要

**解決策**: 外部キー制約を宣言し、データベースに参照整合性を保証させる。

```sql
CREATE TABLE Bugs (
  reported_by BIGINT UNSIGNED NOT NULL,
  FOREIGN KEY (reported_by) REFERENCES Accounts(account_id)
);
```

### 5章 EAV（エンティティ・アトリビュート・バリュー）

**目的**: 可変属性をサポートする。

**アンチパターン**: 汎用的な属性テーブルを使用する。

```sql
-- アンチパターン: EAVテーブル
CREATE TABLE IssueAttributes (
  issue_id BIGINT UNSIGNED NOT NULL,
  attr_name VARCHAR(100) NOT NULL,
  attr_value VARCHAR(100),
  PRIMARY KEY (issue_id, attr_name)
);
```

**問題点**
- データ型が統一できない
- 制約を適用できない
- クエリが複雑になる

**解決策**: サブタイプの数が限定的ならシングルテーブル継承やクラステーブル継承を使用する。属性が動的ならJSONBカラムやドキュメントDBの使用を検討する。

### 6章 ポリモーフィック関連

**目的**: 複数の親テーブルを参照する。

**アンチパターン**: 二重目的の外部キーを使用する。

```sql
-- アンチパターン: ポリモーフィック関連
CREATE TABLE Comments (
  comment_id SERIAL PRIMARY KEY,
  issue_type VARCHAR(20), -- 'Bugs' or 'FeatureRequests'
  issue_id BIGINT UNSIGNED NOT NULL,
  comment TEXT NOT NULL
);
```

**問題点**
- 外部キー制約が使えない
- 参照整合性が保証されない

**解決策**: 交差テーブルを使用するか、共通の親テーブルを作成する。

### 7章 マルチカラムアトリビュート（複数列属性）

**目的**: 複数の値を持つ属性を格納する。

**アンチパターン**: 複数の列を定義する。

```sql
-- アンチパターン: 複数列で格納
CREATE TABLE Bugs (
  bug_id SERIAL PRIMARY KEY,
  tag1 VARCHAR(20),
  tag2 VARCHAR(20),
  tag3 VARCHAR(20)
);
```

**解決策**: 従属テーブルを作成する。

```sql
CREATE TABLE Tags (
  bug_id BIGINT UNSIGNED NOT NULL,
  tag VARCHAR(20) NOT NULL,
  PRIMARY KEY (bug_id, tag),
  FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id)
);
```

### 8章 メタデータトリブル（メタデータ大増殖）

**目的**: スケーラビリティを向上させる。

**アンチパターン**: テーブルや列を複製する（年ごとのテーブル分割など）。

**解決策**: 水平パーティショニングや垂直パーティショニングを使用する。データベースのネイティブパーティショニング機能を活用する。

---

## 第II部: データベース物理設計のアンチパターン

### 9章 ラウンディングエラー（丸め誤差）

**目的**: 整数の代わりに小数値を使用する。

**アンチパターン**: FLOATデータ型を使用する。

```sql
-- アンチパターン: FLOATで価格を格納
ALTER TABLE Bugs ADD COLUMN hours FLOAT;
```

**問題点**
- 浮動小数点の丸め誤差が発生する
- 比較演算が不正確になる

**解決策**: NUMERICまたはDECIMALデータ型を使用する。

```sql
ALTER TABLE Bugs ADD COLUMN hours NUMERIC(9, 2);
```

### 10章 サーティワンフレーバー（31のフレーバー）

**目的**: 列の値を特定の値に制限する。

**アンチパターン**: ENUM型や CHECK制約で値を制限する。

**問題点**
- 値の追加・変更にALTER TABLEが必要
- 他のテーブルで同じ値セットを再利用できない

**解決策**: 参照テーブルを作成する。

```sql
CREATE TABLE BugStatus (
  status VARCHAR(20) PRIMARY KEY
);

CREATE TABLE Bugs (
  bug_id SERIAL PRIMARY KEY,
  status VARCHAR(20) NOT NULL DEFAULT 'NEW',
  FOREIGN KEY (status) REFERENCES BugStatus(status)
);
```

### 11章 ファントムファイル（幻のファイル）

**目的**: 画像やバルクメディアを格納する。

**アンチパターン**: 物理ファイルの使用を必須と決めつける。

**解決策**: 状況に応じてBLOB型での格納も検討する。ファイルパスを格納する場合は、ファイルの整合性管理を適切に行う。

### 12章 インデックスショットガン（闇雲インデックス）

**目的**: パフォーマンスを最適化する。

**アンチパターン**: インデックスを闇雲に作成、または全く作成しない。

**解決策**
- クエリの実行計画（EXPLAIN）を確認する
- 選択度の高い列にインデックスを作成する
- カバリングインデックスを活用する
- 不要なインデックスは削除する

---

## 第III部: クエリのアンチパターン

### 13章 フィア・オブ・ジ・アンノウン（恐怖のunknown）

**目的**: 欠損値を区別する。

**アンチパターン**: NULLを一般値として使用する、またはNULLを避けすぎる。

**問題点**
- NULLとの比較は常にNULLを返す
- 集約関数でNULLが無視される

**解決策**: NULLを一意な値として扱う。IS NULL、IS NOT NULLを使用する。COALESCE関数を活用する。

```sql
-- NULLの適切な扱い
SELECT * FROM Bugs WHERE assigned_to IS NULL;
SELECT COALESCE(hours, 0) FROM Bugs;
```

### 14章 アンビギュアスグループ（曖昧なグループ）

**目的**: GROUP BYでグループごとに最大値や最小値を持つ行を取得する。

**アンチパターン**: グループ化されていない列を参照する。

```sql
-- アンチパターン: 非集約列を参照
SELECT product_id, MAX(date_reported) AS latest, bug_id
FROM Bugs GROUP BY product_id;
```

**解決策**: 相関サブクエリやウィンドウ関数を使用する。

```sql
-- 解決策: ウィンドウ関数を使用
SELECT product_id, date_reported, bug_id
FROM (
  SELECT product_id, date_reported, bug_id,
    ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY date_reported DESC) AS rn
  FROM Bugs
) ranked
WHERE rn = 1;
```

### 15章 ランダムセレクション

**目的**: サンプル行をフェッチする。

**アンチパターン**: データをランダムにソートする。

```sql
-- アンチパターン: ORDER BY RAND()
SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;
```

**問題点**
- テーブル全体のソートが必要でパフォーマンスが悪い
- インデックスが使えない

**解決策**: キー値の範囲からランダムに選択する、OFFSETを使用する、またはアプリケーション側でランダムなキーを生成する。

### 16章 プアマンズ・サーチエンジン（貧者のサーチエンジン）

**目的**: 全文検索を行う。

**アンチパターン**: LIKEやパターンマッチを使用する。

```sql
-- アンチパターン: LIKEで全文検索
SELECT * FROM Bugs WHERE description LIKE '%crash%';
```

**解決策**: データベースの全文検索機能を使用する（PostgreSQLのtsvector/tsquery、MySQLのFULLTEXTインデックスなど）。またはElasticsearchなどの専用検索エンジンを使用する。

### 17章 スパゲッティクエリ

**目的**: 複雑な問題を1つのクエリで解決する。

**アンチパターン**: すべてを1つの複雑なクエリにまとめる。

**解決策**: 複雑なタスクは分割する。CTEを使って可読性を高める。ビューを活用する。

### 18章 インプリシットカラム（暗黙の列）

**目的**: タイピングの手間を減らす。

**アンチパターン**: SELECT * を使用する。

**問題点**
- テーブル構造の変更に弱い
- 不要な列まで取得する
- 列の順序に依存してしまう

**解決策**: 必要な列を明示的に指定する。

```sql
-- 解決策: 列を明示的に指定
SELECT bug_id, date_reported, summary, description, status
FROM Bugs;
```

---

## 第IV部: アプリケーション開発のアンチパターン

### 19章 リーダブルパスワード（読み取り可能パスワード）

**目的**: パスワードを安全に管理する。

**アンチパターン**: パスワードを平文で格納する。

**解決策**: パスワードをソルト付きハッシュで格納する。bcrypt、scrypt、Argon2などの適切なハッシュアルゴリズムを使用する。

### 20章 SQLインジェクション

**目的**: 動的なSQLクエリを記述する。

**アンチパターン**: 未検証のユーザー入力をSQLクエリに連結する。

```python
# アンチパターン: 文字列連結でSQLを構築
query = f"SELECT * FROM Bugs WHERE bug_id = {user_input}"
```

**解決策**: パラメータ化クエリ（プリペアドステートメント）を使用する。

```python
# 解決策: パラメータ化クエリ
query = "SELECT * FROM Bugs WHERE bug_id = %s"
cursor.execute(query, (user_input,))
```

### 21章 シュードキー・ニートフリーク（疑似キー潔癖症）

**目的**: 連番の欠番を埋める。

**アンチパターン**: 欠番を埋めるために行のキーを振り直す。

**解決策**: 欠番は気にしない。疑似キーの値に意味を持たせない。

### 22章 シー・ノー・エビル（臭い物に蓋）

**目的**: 簡潔なコードを書く。

**アンチパターン**: データベースのエラーを無視する。

**解決策**: 必ずエラーハンドリングを行い、エラーの原因を特定できるようにする。

### 23章 ディプロマティック・イミュニティ（外交特権）

**目的**: 開発のルールを定める。

**アンチパターン**: SQLやデータベースを品質管理の対象外にする。

**解決策**: データベースのスキーマもバージョン管理に含め、マイグレーションを使用する。データベースのテストも実施する。

### 24章 スタンダード・オペレーティング・プロシージャ（さびついた開発標準）

**目的**: 開発標準を策定する。

**アンチパターン**: 古い標準を無批判に適用し続ける。

**解決策**: 定期的に開発標準を見直す。新しいデータベース機能やベストプラクティスを取り入れる。

---

## 第V部: ボーナス - 外部キーのミニ・アンチパターン

### 25章 標準SQLにおける外部キーの誤った使い方

**問題**: 外部キーの一般的な誤用パターン。

**解決策**: 外部キーの正しい使い方を理解し、参照整合性を適切に維持する。

### 26章 MySQLにおける外部キーの誤った使い方

**問題**: MySQL特有の外部キーの落とし穴。

**解決策**: MySQLのストレージエンジンごとの外部キーサポートを理解する。InnoDBを使用し、外部キー制約を適切に設定する。

---

## ミニ・アンチパターン一覧

各章末に記載された追加のアンチパターンです。

- **CSV列を複数の行に分割する**: 再帰CTEを使ったトリックは避ける
- **「私のコンピュータでは動作しているのに」**: 環境差異の問題
- **BIGINTは十分に大きい？**: データ型の選択
- **価格の保存**: 通貨データの適切な格納方法
- **予約語**: SQLの予約語との名前衝突
- **すべての列にインデックスを作成する**: 不要なインデックスの問題
- **NOT IN (NULL)**: NULLを含むサブクエリの落とし穴
- **ポータブルSQL**: 移植性と機能のトレードオフ
- **クエリでランダムに複数行を取得する**: ランダム選択の効率化
- **ハッシュ文字列をVARCHAR型で格納する**: 固定長ハッシュの格納
- **引用符内のクエリパラメータ**: パラメータ化の誤り
- **グループごとの自動インクリメント**: グループ単位の連番
- **構文エラーメッセージ解読のすすめ**: エラーメッセージの読み方
- **名前の変更**: リネーミングの注意点
- **MySQLのストアドプロシージャ**: ストアドプロシージャの適切な使用

---

## レビュー時のチェックリスト

データベース関連のコードをレビューする際は、以下の観点で確認してください。

### 論理設計の観点
- [ ] カンマ区切りでリストを格納していないか（ジェイウォーク）
- [ ] 階層構造の格納方法は適切か（ナイーブツリー）
- [ ] 主キーの設計は適切か（IDリクワイアド）
- [ ] 外部キー制約が設定されているか（キーレスエントリ）
- [ ] EAVパターンを不用意に使用していないか
- [ ] ポリモーフィック関連を使用していないか
- [ ] 複数列属性を使用していないか

### 物理設計の観点
- [ ] FLOATで金額や精度が必要な値を格納していないか（ラウンディングエラー）
- [ ] ENUMの代わりに参照テーブルを使用しているか（サーティワンフレーバー）
- [ ] インデックスの設計は適切か（インデックスショットガン）

### クエリの観点
- [ ] NULLの扱いは適切か（フィア・オブ・ジ・アンノウン）
- [ ] GROUP BYで非集約列を参照していないか（アンビギュアスグループ）
- [ ] ORDER BY RAND()を使用していないか（ランダムセレクション）
- [ ] LIKEで全文検索をしていないか（プアマンズ・サーチエンジン）
- [ ] クエリが複雑すぎないか（スパゲッティクエリ）
- [ ] SELECT * を使用していないか（インプリシットカラム）

### アプリケーション開発の観点
- [ ] パスワードが平文で格納されていないか（リーダブルパスワード）
- [ ] SQLインジェクション対策がされているか
- [ ] データベースエラーのハンドリングが適切か（シー・ノー・エビル）
- [ ] データベーススキーマがバージョン管理されているか（ディプロマティック・イミュニティ）

## 結論

ひとつひとつの値は個別の行と列に格納しましょう。
愚者は経験に学び、賢者は歴史に学ぶ。「悪いこと」をまとめた知識は、他人の失敗から学び、自分の失敗を回避する助けになります。
